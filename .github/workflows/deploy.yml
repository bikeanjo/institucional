name: Deploy to Production

on:
  push:
    branches:
      - stage
  workflow_dispatch:

jobs:
  deploy:
    name: Deploy to Linode Server
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup SSH
        env:
          SSH_PRIVATE_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
        run: |
          set -e
          mkdir -p ~/.ssh
          chmod 700 ~/.ssh

          # Save private key
          echo "$SSH_PRIVATE_KEY" > ~/.ssh/deploy_key
          chmod 600 ~/.ssh/deploy_key

          # Verify key format
          if ! grep -q "BEGIN.*PRIVATE KEY" ~/.ssh/deploy_key; then
            echo "ERROR: SSH_PRIVATE_KEY does not appear to be a valid private key"
            echo "Key should start with -----BEGIN and end with -----END"
            exit 1
          fi

          # Add server to known_hosts
          ssh-keyscan -H "$SSH_HOST" >> ~/.ssh/known_hosts 2>/dev/null || true
          chmod 600 ~/.ssh/known_hosts

          # Test SSH connection with verbose output for debugging
          echo "Testing SSH connection to ${SSH_USER}@${SSH_HOST}..."
          ssh -v -i ~/.ssh/deploy_key \
            -o StrictHostKeyChecking=no \
            -o UserKnownHostsFile=~/.ssh/known_hosts \
            -o ConnectTimeout=10 \
            ${SSH_USER}@${SSH_HOST} "echo 'SSH connection successful'" || {
            echo "ERROR: SSH connection failed"
            echo "Please verify:"
            echo "  1. SSH_PRIVATE_KEY is correctly set in secrets"
            echo "  2. SSH_HOST is correct: $SSH_HOST"
            echo "  3. SSH_USER is correct: $SSH_USER"
            echo "  4. Server is accessible and firewall allows SSH"
            exit 1
          }

          echo "✓ SSH connection successful"

      - name: Sync files to server
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          rsync -avz --delete \
            -e "ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no" \
            --exclude 'node_modules' \
            --exclude 'dist' \
            --exclude '.git' \
            --exclude 'ianthomaz' \
            --exclude '.env' \
            --exclude '.env.stage' \
            --exclude '.DS_Store' \
            --exclude '.github' \
            ./ ${SSH_USER}@${SSH_HOST}:${DEPLOY_PATH}/

      - name: Copy production environment files
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          # Copy deploy/.env.prod if it exists locally
          if [ -f "deploy/.env.prod" ]; then
            echo "Copying deploy/.env.prod from repository..."
            scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
              deploy/.env.prod ${SSH_USER}@${SSH_HOST}:${DEPLOY_PATH}/deploy/.env.prod
          else
            echo "⚠ WARNING: deploy/.env.prod not found in repository (gitignored)"
            echo "Creating .env.prod on server with values from GitHub Secrets..."
            ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@${SSH_HOST} bash << EOF
              cat > ${DEPLOY_PATH}/deploy/.env.prod << 'ENV_EOF'
ENV=production
FRONTEND_PORT=8080
API_PORT=3000
FRONTEND_BIND=0.0.0.0
API_BIND=0.0.0.0
DEPLOY_LOCAL=false
DEPLOY_HOST=${{ secrets.SSH_HOST }}
DEPLOY_PATH=${{ secrets.DEPLOY_PATH }}
DOMAIN_PRIMARY=${{ secrets.DOMAIN_PRIMARY }}
SSL_EMAIL=${{ secrets.SSL_EMAIL }}
ENV_EOF
            EOF
          fi

          # Verify .env.prod exists on server
          echo "Verifying .env.prod exists on server..."
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@${SSH_HOST} \
            "test -f ${DEPLOY_PATH}/deploy/.env.prod" || {
            echo "ERROR: .env.prod does not exist on server after copy/create!"
            exit 1
          }
          echo "✓ .env.prod verified on server"

          # Copy api/.env.prod if it exists locally
          if [ -f "api/.env.prod" ]; then
            echo "Copying api/.env.prod from repository..."
            scp -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no \
              api/.env.prod ${SSH_USER}@${SSH_HOST}:${DEPLOY_PATH}/api/.env
          else
            echo "⚠ WARNING: api/.env.prod not found in repository (gitignored)"
            echo "Note: api/.env should exist on server from previous deployments"
          fi

      - name: Deploy on server
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          DOMAIN_PRIMARY: ${{ secrets.DOMAIN_PRIMARY }}
          SSL_EMAIL: ${{ secrets.SSL_EMAIL }}
        run: |
          echo "DEPLOY_PATH value: ${DEPLOY_PATH}"
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@${SSH_HOST} bash -s << EOF
            set -e
            export DEPLOY_PATH="${DEPLOY_PATH}"
            echo "Remote DEPLOY_PATH: \$DEPLOY_PATH"
            if [ -z "\$DEPLOY_PATH" ]; then
              echo "ERROR: DEPLOY_PATH is empty!"
              exit 1
            fi
            cd "\$DEPLOY_PATH/deploy" || {
              echo "ERROR: Cannot cd to \$DEPLOY_PATH/deploy"
              echo "Current directory: \$(pwd)"
              echo "Listing \$DEPLOY_PATH:"
              ls -la "\$DEPLOY_PATH" || echo "Directory does not exist"
              exit 1
            }
            
            # Validate and load environment variables from .env.prod
            if [ ! -f .env.prod ]; then
              echo "ERROR: .env.prod file not found!"
              echo "This file is required for deployment."
              exit 1
            fi
            
            echo "  → Loading environment variables from .env.prod..."
            source .env.prod
            
            # Validate required variables
            if [ -z "\$ENV" ] || [ -z "\$FRONTEND_PORT" ] || [ -z "\$API_PORT" ]; then
              echo "ERROR: Required environment variables missing!"
              echo "ENV=\${ENV}, FRONTEND_PORT=\${FRONTEND_PORT}, API_PORT=\${API_PORT}"
              exit 1
            fi
            
            COMPOSE_FILE="docker-compose-bikeanjo-institucional.yml"
            
            echo "  → Environment variables loaded:"
            export ENV=\${ENV}
            export FRONTEND_PORT=\${FRONTEND_PORT}
            export API_PORT=\${API_PORT}
            export FRONTEND_BIND=\${FRONTEND_BIND:-0.0.0.0}
            export API_BIND=\${API_BIND:-0.0.0.0}
            echo "    ENV: \$ENV"
            echo "    Frontend: \$FRONTEND_BIND:\$FRONTEND_PORT"
            echo "    API: \$API_BIND:\$API_PORT"
            
            echo "  → Stopping existing containers..."
            docker compose -f \$COMPOSE_FILE down 2>/dev/null || true
            
            echo "  → Building containers (this may take a while)..."
            echo "    - Building API container..."
            docker compose -f \$COMPOSE_FILE build api
            
            echo "    - Building Frontend container..."
            docker compose -f \$COMPOSE_FILE build frontend
            
            echo "  → Starting containers..."
            docker compose -f \$COMPOSE_FILE up -d || {
              echo "ERROR: Failed to start containers"
              docker compose -f \$COMPOSE_FILE logs
              exit 1
            }
            
            echo "  → Waiting for containers to be healthy..."
            sleep 10
            
            echo ""
            echo "=== Container Status ==="
            docker compose -f \$COMPOSE_FILE ps
            
            # Validate containers are running
            RUNNING_CONTAINERS=\$(docker compose -f \$COMPOSE_FILE ps --filter "status=running" --format "{{.Name}}" | wc -l)
            EXPECTED_CONTAINERS=2
            
            if [ "\$RUNNING_CONTAINERS" -lt "\$EXPECTED_CONTAINERS" ]; then
              echo ""
              echo "ERROR: Not all containers are running!"
              echo "Expected: \$EXPECTED_CONTAINERS, Running: \$RUNNING_CONTAINERS"
              echo ""
              echo "Container logs:"
              docker compose -f \$COMPOSE_FILE logs --tail=50
              exit 1
            fi
            
            echo ""
            echo "  ✓ Docker deployment complete!"
            echo "  ✓ All containers running (\$RUNNING_CONTAINERS/\$EXPECTED_CONTAINERS)"
          EOF

      - name: Configure Nginx
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@${SSH_HOST} bash << EOF
            set -e
            export DEPLOY_PATH="${DEPLOY_PATH}"
            
            echo "  → Checking nginx installation..."
            if ! command -v nginx &> /dev/null; then
              echo "  → Installing nginx..."
              apt update -qq && apt install -y nginx > /dev/null
              echo "  ✓ Nginx installed"
            else
              echo "  ✓ Nginx already installed"
            fi
            
            echo "  → Copying nginx configuration..."
            cp \${DEPLOY_PATH}/deploy/nginx-host.conf /etc/nginx/sites-available/bikeanjo-institucional
            
            echo "  → Enabling site..."
            ln -sf /etc/nginx/sites-available/bikeanjo-institucional /etc/nginx/sites-enabled/bikeanjo-institucional
            rm -f /etc/nginx/sites-enabled/default
            
            echo "  → Testing nginx configuration..."
            nginx -t
            
            echo "  → Reloading nginx..."
            systemctl reload nginx
            
            echo "  ✓ Nginx configured successfully"
          EOF

      - name: Configure SSL (if needed)
        env:
          SSH_HOST: ${{ secrets.SSH_HOST }}
          SSH_USER: ${{ secrets.SSH_USER }}
          DOMAIN_PRIMARY: ${{ secrets.DOMAIN_PRIMARY }}
          SSL_EMAIL: ${{ secrets.SSL_EMAIL }}
        run: |
          ssh -i ~/.ssh/deploy_key -o StrictHostKeyChecking=no ${SSH_USER}@${SSH_HOST} bash << EOF
            set -e
            export DOMAIN_PRIMARY="${DOMAIN_PRIMARY}"
            export SSL_EMAIL="${SSL_EMAIL}"
            
            echo "  → Checking certbot installation..."
            if ! command -v certbot &> /dev/null; then
              echo "  → Installing certbot..."
              apt install -y certbot python3-certbot-nginx > /dev/null
              echo "  ✓ Certbot installed"
            else
              echo "  ✓ Certbot already installed"
            fi
            
            echo "  → Enabling nginx service..."
            systemctl enable nginx > /dev/null 2>&1
            systemctl start nginx > /dev/null 2>&1
            
            echo "  → Checking SSL certificate for \${DOMAIN_PRIMARY}..."
            if [ ! -d "/etc/letsencrypt/live/\${DOMAIN_PRIMARY}" ]; then
              echo "  → Obtaining SSL certificate from Let's Encrypt..."
              certbot --nginx \
                -d \${DOMAIN_PRIMARY} \
                --non-interactive \
                --agree-tos \
                --email \${SSL_EMAIL} \
                --redirect || echo "  ⚠ SSL configuration skipped (certificate may already exist or DNS not ready)"
            else
              echo "  ✓ SSL certificate already exists for \${DOMAIN_PRIMARY}"
            fi
            
            echo "  → Enabling automatic SSL renewal..."
            systemctl enable certbot.timer > /dev/null 2>&1 || true
            systemctl start certbot.timer > /dev/null 2>&1 || true
            echo "  ✓ Auto-renewal configured"
          EOF

      - name: Health check
        env:
          DOMAIN_PRIMARY: ${{ secrets.DOMAIN_PRIMARY }}
        run: |
          echo "  → Waiting for services to be ready..."
          sleep 10

          echo "  → Testing frontend..."
          if curl -s --max-time 10 "http://${DOMAIN_PRIMARY}/" | grep -q "Bike Anjo" 2>/dev/null; then
            echo "  ✓ Frontend is responding"
          else
            echo "  ⚠ Frontend health check failed (may still be starting)"
          fi

          echo "  → Testing API..."
          if curl -s --max-time 10 "http://${DOMAIN_PRIMARY}/api/health" | grep -q "OK" 2>/dev/null; then
            echo "  ✓ API is responding"
          else
            echo "  ⚠ API health check failed (may still be starting)"
          fi

          echo ""
          echo "========================================="
          echo "✓ DEPLOYMENT COMPLETE!"
          echo "========================================="
          echo ""
          echo "Site URLs:"
          echo "  • HTTPS: https://${DOMAIN_PRIMARY}"
          echo "  • API:   https://${DOMAIN_PRIMARY}/api/health"
